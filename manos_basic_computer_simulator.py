# -*- coding: utf-8 -*-
"""COE341 Project Final Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o7v3z4Tq604bAjxILKIl7DrY-Pe4XJrL

#REMINDER:
-> At each visible step, the simulator must display:
1) Instruction in hand: 0x3120
2) Micro-operation: T4: DR ← M[AR]
3) Components changed during that step - Changed: DR
"""

#Imports

from google.colab import drive
drive.mount('/content/drive')

"""## Main Function, Register Initilizations, and Program/Data Reading - Block 1"""

#Defining the Memory:
mem=[0] * 65536 #Memory of size 4096 x 16

# Read from Txt file
program = [] # Initialize program list
data = []    # Initialize data list

# Importing and reading the program instructions from the file
p = open("/content/drive/My Drive/Comp Arch Project/program.txt")
for line in p:
  line_data = line.split() #Splitting the input line by line based on a space
  first = int(line_data[0], 16) #input data as hex
  second = int(line_data[1], 16) #input data as hex
  program.append([first, second]) #add entry into array

p.close()

# Importing and reading the data from the file
p = open("/content/drive/My Drive/Comp Arch Project/data.txt")
for line in p:
  line_data = line.split() #Splitting the input line by line based on a space
  first = int(line_data[0], 16) #input data as hex
  second = int(line_data[1], 16) #input data as hex
  data.append([first, second]) #add entry into array

p.close()

# Load program into memory
for addr, value in program:
    mem[addr] = value

# Load data into memory
for addr, value in data:
    mem[addr] = value

#Basic Computer Registers - in HEX

# Defining the registers
DR = 0  # Data Register - 16bits
AR = 0    # Address Register - 12bits
AC = 0   # Accumulator - 16bits
IR = 0  # Instruction Register - 16bits
PC = int(str(program[0][0]))  # Program Counter - 12bits, initialized to start of program
TR = 0   # Temporary Register - 16bits

#Basic computer flags
E_flag = 0 #Carry flag
I_flag = 0 #indirect/direct flag
s_flag = 1 #start flag - initilized to 1, to allow the program to start

#Opp code:
opp = 0 #holds the oppcode in decimal

#---------------------------------------------------------------------------------------------------------------------

# Counters / State
seq_count = 0  # Sequence counter - helps keep track of the clock cycle
inst_count = 0 # Instruction count - Holds number of instructions executed
sum_count = 0 # Sum of all counts from counts array
avg_count = 0  # Average of all counts
RW_count = 0  # Number of memory reads/writes

"""## Fetch and Decode Functions - Block 2"""

# function to decode the opcode
def opp_decode(value):

    # Shift right by 12 bits to isolate the first hex digit
    first_hex_digit = (value >> 12) & 0xF

    # Take the last 3 bits of that digit to determine the opp code
    opp = first_hex_digit & 0b0111

    return opp

# function to extract the direct/indirect bit
def indirect_bit(value):
    # Extract the first hex digit (top 4 bits)
    first_hex_digit = (value >> 12) & 0xF

    # Extract the most significant bit of that hex digit
    I = (first_hex_digit >> 3) & 0b1

    return I

# function to extract the address
def address(value):
    # Mask the lower 12 bits (3 hex digits)
    addr = value & 0xFFF
    return addr

def inst_parse_step():

    global AC, PC, IR, I_flag, opp, seq_count, s_flag, mem, sum_count, AR

    if s_flag == 0:
        print("The program has halted!")
        return

    # T0: AR <- PC
    if seq_count == 0:
        AR = PC
        print("Instruction in hand: N/A")
        print("Micro operation in hand T", seq_count, ": AR<- PC")
        print("Changed: AR")
        seq_count += 1
        sum_count += 1
        return

    # T1: IR <- M[AR], PC <- PC+1
    elif seq_count == 1:
        IR = mem[AR]
        PC = (PC + 1) & 0xFFF  # 12-bit PC
        print("Instruction in hand:", hex(IR))
        print("Micro operation in hand T", seq_count, ": IR <- M[AR], PC <- PC+1")
        print("Changed: IR and PC")
        seq_count += 1
        sum_count += 1
        return

    # T2: decode
    elif seq_count == 2:
        opp = opp_decode(IR)
        I_flag = indirect_bit(IR)
        AR = address(IR)  # address part of IR
        print("Instruction in hand:", hex(IR))
        print("Micro operation in hand T", seq_count,
              ": D0, …, D7 ← Decode IR(12-14), AR ← IR(0-11), I ← IR(15)")
        print("Changed: opp_code and AR and I flag")
        seq_count += 1   # move to T3
        sum_count += 1
        return

    return

"""## Execution Function: Memory and Register Intsructions - Block 3"""

# every reg refrence is 1 instruction so in each one sc<-0
# throughout the prints, IR is explicitly converted to hex for proper output


# function to clear the AC register
def CLA():
  global AC,seq_count,IR,sum_count, inst_count

  # setting the value of AC to zero
  AC=0
  print("Micro operation in hand T",seq_count,": AC<- 0")
  seq_count=0
  inst_count+=1
  sum_count+=1
  print("Instruction in hand:", hex(IR))

  print("Changed: AC and SC")
  return

# function to clear the E flag
def CLE():
  global E_flag,seq_count,IR,sum_count, inst_count
  E_flag=0
  print("Micro operation in hand T",seq_count,": E<- 0")
  seq_count=0
  inst_count+=1
  sum_count+=1
  print("Instruction in hand:", hex(IR))

  print("Changed: E flag and SC")
  return

# function to complement the AC register
def CMA():
    global AC,seq_count,IR,sum_count, inst_count
    AC = (~AC) & 0xFFFF # Ensures AC stays within 16 bits
    print("Micro operation in hand T",seq_count,": AC<- AC'")
    seq_count=0
    inst_count+=1
    sum_count+=1
    print("Instruction in hand:", hex(IR))
    print("Changed: AC and SC")
    return

# function to complement the E flag
def CME():
    global E_flag,seq_count,IR,sum_count, inst_count
    inst_count+=1
    sum_count+=1
    E_flag = 1 - E_flag # Toggles E_flag between 0 and 1
    print("Micro operation in hand T",seq_count,": E<- E'")
    seq_count=0
    print("Instruction in hand:", hex(IR))

    print("Changed: E flag and SC")
    return

# function to circulate right
def CIR():
    global AC, E_flag,seq_count,IR,sum_count, inst_count

    lsb = AC & 1

    # Shift AC right by 1
    AC = (AC >> 1) & 0x7FFF  # mask 15 bits to keep AC 16-bit

    # Put E into AC(15) — most significant bit

    AC = AC | ((E_flag & 1) << 15)

    # Update E with original AC(0)
    E_flag = lsb
    print("Micro operation in hand T",seq_count,": AC<- shr AC, AC(15)<-E, E<-AC(0)")
    seq_count=0
    inst_count+=1
    sum_count+=1
    print("Instruction in hand:", hex(IR))
    print("Changed: E flag and AC and SC")
    return

# function to circulate left
def CIL():
    global AC, E_flag,seq_count,IR,sum_count, inst_count

    # Store AC(15) — most significant bit
    msb = (AC >> 15) & 1

    # Shift AC left by 1
    AC = (AC << 1) & 0xFFFF  # keep AC 16-bit

    # Put E into AC(0) — least significant bit
    AC = AC | (E_flag & 1)

    # Update E with original AC(15)
    E_flag = msb

    print("Micro operation in hand T",seq_count,": AC<- shl AC, AC(10)<-E, E<-AC(15)")

    seq_count=0
    inst_count+=1
    sum_count+=1
    print("Instruction in hand:", hex(IR))
    print("Changed: E flag and AC and SC")
    return

# function to increment the AC register
def INC():
    global AC,seq_count,IR,sum_count, inst_count

    AC=(AC+1) & 0xFFFF # Ensure AC stays within 16 bits
    print("Micro operation in hand T",seq_count,": AC<-AC+1")
    seq_count=0
    inst_count+=1
    sum_count+=1
    print("Instruction in hand:", hex(IR))
    print("Changed: AC and SC")
    return

# function to skip next instruction if AC is positive
def SPA():
    global AC, PC, seq_count, IR, sum_count, inst_count

    print("Instruction in hand:", hex(IR))
    # extracting the sign bit and comparing if it is zero
    if ((AC >> 15) & 1) == 0:
      PC = (PC + 1) & 0xFFF
      print("Micro operation in hand T", seq_count, ": if(AC(15)=0) then, PC <- PC + 1, SC<-0")
      print("Changed: PC and SC")
    else:
      print("Micro operation in hand T", seq_count, ": SC<- 0")
      print("Changed: SC")

    seq_count=0
    inst_count+=1
    sum_count+=1
    return

# function to skip next instruction if AC is negative
def SNA():
    global AC, PC, seq_count, IR, sum_count, inst_count

    print("Instruction in hand:", hex(IR))

    # extracting the sign bit and comparing if it is one
    if ((AC >> 15) & 1) == 1:
      PC = (PC + 1) & 0xFFF
      print("Micro operation in hand T", seq_count, ": if(AC(15)=1) then, PC <- PC + 1, SC<-0")
      print("Changed: PC and SC")
    else:
      print("Micro operation in hand T", seq_count, ": SC<- 0")
      print("Changed: SC")
    seq_count=0
    inst_count+=1
    sum_count+=1
    return

# function to skip next instruction if AC is zero
def SZA():
    global AC, PC, seq_count, IR, sum_count, inst_count

    print("Instruction in hand:", hex(IR))

    if (AC==0):
      PC = (PC + 1) & 0xFFF
      print("Micro operation in hand T", seq_count, ": if(AC=0) then, PC <- PC + 1, SC<-0")
      print("Changed: PC and SC")
    else:
      print("Micro operation in hand T", seq_count, ": SC<- 0")
      print("Changed: SC")
    seq_count=0
    inst_count+=1
    sum_count+=1
    return

# function to skip next instruction if E flag is zero
def SZE():
    global PC, E_flag, seq_count, IR,sum_count, inst_count

    print("Instruction in hand:", hex(IR))

    if (E_flag==0):
      PC = (PC + 1) & 0xFFF
      print("Micro operation in hand T", seq_count, ": if(E=0) then, PC <- PC + 1, SC<-0")
      print("Changed: PC and SC")
    else:
      print("Micro operation in hand T", seq_count, ": SC<- 0")
      print("Changed: SC")
    seq_count=0
    inst_count+=1
    sum_count+=1
    return

#Halt function, to be used when 0x7001 is reached at the end of the program
def HLT():
    global s_flag,seq_count,IR,sum_count, inst_count
    s_flag=0
    print("Micro operation in hand T",seq_count,": S<-0")
    seq_count=0
    inst_count+=1
    sum_count+=1
    print("Instruction in hand:", hex(IR))

    print("Changed: S and SC")
    return

def execute_T_step():

    global opp, I_flag, AR, mem, RW_count, seq_count, sum_count
    global IR, s_flag, DR, AC, E_flag, PC, inst_count

    if s_flag == 0:
        print("Program halted — cannot execute next cycle.")
        return

    # MEMORY REFERENCE (D0–D6)
    # T3: indirect addressing / direct addressing
    if opp in [0, 1, 2, 3, 4, 5, 6]:

        # T3
        if seq_count == 3:
            # Indirect: AR <- M[AR]
            if I_flag == 1:
                AR = mem[AR]
                RW_count += 1
                print("Instruction in hand:", hex(IR))
                print("Micro operation in hand T", seq_count, ": AR ← M[AR]")
                print("Changed: AR")
                sum_count += 1
            else:
                # Direct: no real micro-op, but we still count the cycle
                print("Instruction in hand:", hex(IR))
                print("Micro operation in hand T", seq_count,
                      ": (direct addressing) No operation")
                print("Changed: SC")
                sum_count += 1

            seq_count+= 1   # move to T4 next
            return

        # T4
        elif seq_count == 4:
            # AND: T4 = DR <- M[AR]
            if opp == 0:
                DR = mem[AR]
                RW_count += 1
                print("Instruction in hand:", hex(IR))
                print("Micro operation in hand T", seq_count, ": DR <- M[AR]")
                print("Changed: DR and SC")
                sum_count += 1
                seq_count+= 1   # next is T5 of AND
                return

            # ADD: T4 = DR <- M[AR]
            elif opp == 1:
                DR = mem[AR]
                RW_count += 1
                print("Instruction in hand:", hex(IR))
                print("Micro operation in hand T", seq_count, ": DR <- M[AR]")
                print("Changed: DR and SC")
                sum_count += 1
                seq_count+= 1
                return

            # LDA: T4 = DR <- M[AR]
            elif opp == 2:
                DR = mem[AR]
                RW_count += 1
                print("Instruction in hand:", hex(IR))
                print("Micro operation in hand T", seq_count, ": DR <- M[AR]")
                print("Changed: DR and SC")
                sum_count += 1
                seq_count+= 1
                return

            # STA: T4 = M[AR] <- AC, SC <- 0
            elif opp == 3:
                mem[AR] = AC
                RW_count += 1
                print("Instruction in hand:", hex(IR))
                print("Micro operation in hand T", seq_count, ": M[AR] <- AC, SC <-0")
                print("Changed: Memory and SC")
                sum_count += 1
                inst_count += 1
                seq_count = 0     # instruction finished
                return

            # BUN: T4 = PC <- AR, SC <- 0
            elif opp == 4:
                PC = AR & 0xFFF
                print("Instruction in hand:", hex(IR))
                print("Micro operation in hand T", seq_count, ": PC <- AR, SC<- 0")
                print("Changed: PC and SC")
                sum_count += 1
                inst_count += 1
                seq_count = 0
                return

            # BSA: T4 = M[AR] <- PC, AR <- AR+1
            elif opp == 5:
                mem[AR] = PC
                RW_count += 1
                AR = (AR + 1) & 0xFFF
                print("Instruction in hand:", hex(IR))
                print("Micro operation in hand T", seq_count,
                      ": M[AR] <- PC, AR <- AR + 1")
                print("Changed: Memory and AR and SC")
                sum_count += 1
                seq_count+= 1    # T5 of BSA next
                return

            # ISZ: T4 = DR <- M[AR]
            elif opp == 6:
                DR = mem[AR]
                RW_count += 1
                print("Instruction in hand:", hex(IR))
                print("Micro operation in hand T", seq_count, ": DR <- M[AR]")
                print("Changed: DR and SC")
                sum_count += 1
                seq_count+= 1    # T5 of ISZ next
                return

        # T5
        elif seq_count == 5:
            # AND: T5 = AC <- AC AND DR, SC <- 0
            if opp == 0:
                AC = AC & DR
                print("Instruction in hand:", hex(IR))
                print("Micro operation in hand T", seq_count,
                      ": AC <- AC AND DR, SC <- 0")
                print("Changed: AC and SC")
                sum_count += 1
                inst_count += 1
                seq_count = 0
                return

            # ADD: T5 = AC <- AC + DR, E <- Cout, SC <- 0
            elif opp == 1:
                total = AC + DR
                E_flag = (total >> 16) & 1
                AC = total & 0xFFFF

                print("Instruction in hand:", hex(IR))
                print("Micro operation in hand T", seq_count,
                      ": AC <- AC + DR, E <- Cout, SC <- 0")
                print("Changed: AC and E flag and SC")
                sum_count += 1
                inst_count += 1
                seq_count = 0
                return

            # LDA: T5 = AC <- DR, SC <- 0
            elif opp == 2:
                AC = DR
                print("Instruction in hand:", hex(IR))
                print("Micro operation in hand T", seq_count,
                      ": AC <- DR, SC <- 0")
                print("Changed: AC and SC")
                sum_count += 1
                inst_count += 1
                seq_count = 0
                return

            # BSA: T5 = PC <- AR, SC <- 0
            elif opp == 5:
                PC = AR
                print("Instruction in hand:", hex(IR))
                print("Micro operation in hand T", seq_count,
                      ": PC <- AR, SC <- 0")
                print("Changed: PC and SC")
                sum_count += 1
                inst_count += 1
                seq_count = 0
                return

            # ISZ: - DR <- DR + 1
            #      - mem[AR] <- DR, if DR == 0, PC <- PC+1
            elif opp == 6:

                DR = (DR + 1) & 0xFFFF
                mem[AR] = DR
                RW_count += 1

                print("Instruction in hand:", hex(IR))
                if DR == 0:
                    PC = (PC + 1) & 0xFFF
                    print("Micro operation in hand T", seq_count,
                          ": DR <- DR + 1, M[AR] <- DR, PC <- PC + 1, SC <- 0")
                    print("Changed: DR, Memory, PC and SC")
                else:
                    print("Micro operation in hand T", seq_count,
                          ": DR <- DR + 1, M[AR] <- DR, SC <- 0")
                    print("Changed: DR, Memory and SC")

                sum_count += 1
                inst_count += 1
                seq_count = 0
                return

        return

    # REGISTER-REFERENCE (D7, I=0)
    if opp == 7 and I_flag == 0 and seq_count == 3:

        micro = IR & 0x0FFF

        if micro == 0x800: CLA()
        elif micro == 0x400: CLE()
        elif micro == 0x200: CMA()
        elif micro == 0x100: CME()
        elif micro == 0x080: CIR()
        elif micro == 0x040: CIL()
        elif micro == 0x020: INC()
        elif micro == 0x010: SPA()
        elif micro == 0x008: SNA()
        elif micro == 0x004: SZA()
        elif micro == 0x002: SZE()
        elif micro == 0x001: HLT()
        return

    # I/O (D7, I=1) – Not included so ignored for the project
    if opp == 7 and I_flag == 1 and seq_count == 3:
        print("Instruction in hand:", hex(IR))
        print("Micro operation in hand T", seq_count,": I/O instruction (not supported)")
        print("Changed: SC")
        sum_count += 1
        seq_count = 0
        return

"""##Inspection commands - Block 4



"""

def show_reg_name(register): #shows content of a register specfied by the user
    name = register.upper()

    # Make all variables defined globally
    globals_dict = globals()

    if name in globals_dict:
        value = globals_dict[name]
        return f"{hex(value)} (binary: {value:016b})"
    else:
        return "No register called,",name," exists please input a valid register"


def show_mem_address(addr): #shows content of ONE memory addr. specfied by user
  global mem
  if(int(addr)<65535 and int(addr)>=0):
    return f"M[{int(addr)}] = 0x{mem[int(addr)]:04X} (binary: {mem[int(addr)]:016b})"
  else:
    return "Please input a memory addr. less than 65535 and greater than 0"



def show_mem_address_n(addr,num): #shows content of the memory address specfied by the user. Num represents how many memory addr. user wants to show
    global mem
    addr = int(addr)
    num = int(num)

    # Validate starting address
    if addr < 0 or addr > 65535:
        print("Please input a starting memory address between 0 and 65535")
        return

    # Validate num
    if num <= 0:
        print("Please input a positive number of memory addresses to show")
        return

    # Validate end range
    if addr + num - 1 > 65535:
        print("Requested range exceeds memory size (0 to 65535)")
        return

    #print valid values of mem
    for i in range(addr, addr + num):
        print(f"0x{i:03X} | 0x{mem[i]:04X}")

    return


def show_all(): #shows contetnt of all the registers and E and I and SC
  global DR,AR,AC,IR,PC,TR,E_flag,I_flag,seq_count
  print("DR =", hex(DR))
  print("AR =", hex(AR))
  print("AC =", hex(AC))
  print("IR =", hex(IR))
  print("PC =", hex(PC))
  print("TR =", hex(TR))
  print("E flag =", bin(E_flag)) #bin casts to binary
  print("I flag =", bin(I_flag))
  print("S flag =",bin(s_flag))
  print("Sequence Counter =", seq_count)
  return

def show_profiler(): #shows profiler
  global sum_count,inst_count,avg_count,RW_count
  avg_count=sum_count/inst_count #calculates the CPI

  print("Below is the profiler of the process: ")
  print("The total cycles executed until now is: ",sum_count) #total cycles executed
  print("The total number of instructions executed till now is: ",inst_count) #total number of instructions executed
  print("The average cycles per instruction (CPI) is: ",avg_count); # average cycles per instruction (CPI)
  print("The total memory bandwidth until now, which includes number of memory read and writes is: ", RW_count) # memory bandwidth (total memory reads and writes)
  return

"""##Command line Control functions [Cycle level commands] - Block 5

"""

def next_cycle():  # executes next clock cycle
    global s_flag, seq_count

    if s_flag == 0:
        print("HLT encountered — cannot execute next cycle.")
        return

    # Fetch/decode phase
    if seq_count in (0, 1, 2):
        inst_parse_step()

    # Execute phase
    else:  # seq_count >= 3
        execute_T_step()


def fast_cycle(N):  # executes N clock cycles in sequence
    global s_flag

    for _ in range(N):
        if s_flag == 0:
            print("HLT encountered — cannot execute next cycle.")
            return

        next_cycle()

def next_inst():
    global s_flag

    if s_flag == 0:
        print("HLT encountered — cannot execute next instruction.")
        return

    # T0–T2
    while seq_count < 3:
      inst_parse_step()

    # T3 (+ instruction execution)
    execute_T_step()


def fast_inst(N): # Fast_inst N executes N instruction cycles in sequence.
  global s_flag

  # Executing N instructions using a loop
  for i in range(1, N + 1):
    if s_flag == 0:
        print("HLT encountered — cannot execute next instruction.")
        return

    # T0–T2
    while seq_count < 3:
        inst_parse_step()

    # T3 (+ instruction execution)
    execute_T_step()

  return

def run(): #executes the whole program until it the HLT instruction (0x7001) is encountered.
  global s_flag, IR, PC

  if s_flag == 0:
      print("Cannot run — HLT has already been executed.")
      return

  print("Starting program execution...")

  # Loop until HLT is reached
  while s_flag == 1:

      next_cycle()

  print("\nProgram halted. HLT instruction encountered.")
  print("Below is the program profilier!")
  show_profiler()

  return

"""##Outputs - Block 6



"""

exec_menu = """
Execution Phase Menu
=====================================================================
Please enter your command of interest:
1. next_cycle – executes one clock cycle.
2. fast_cycle N – executes N clock cycles in sequence.
3. next_inst – executes one full instruction cycle.
4. fast_inst N – executes N instruction cycles in sequence.
5. run – executes the whole program until it the HLT instruction is encountered \n
Inspection Phase Menu
=====================================================================
Please enter your command of interest:
6. show_reg_name REGISTER_NAME
7. show mem address
8. show mem address memory_count
9. show all
10. show profiler
11. end - To end the program
\n"""

while True:
    x = input(exec_menu).strip()

    if x == "end":
        break

    parts = x.split()

    if len(parts) == 0:
        continue

    command = parts[0].lower()

    if command == "next_cycle":
        next_cycle()
    elif command == "fast_cycle":
        fast_cycle(int(parts[1]))
    elif command == "next_inst":
        next_inst()
    elif command == "fast_inst":
        fast_inst(int(parts[1]))
    elif command == "run":
        run()
    elif command == "show_reg_name":
        print(show_reg_name(parts[1]))
    elif command == "show" and len(parts) >= 2 and parts[1].lower() == "mem":
        start = int(parts[2])
        if len(parts) == 4:
            count = int(parts[3])
            show_mem_address_n(start, count)
        else:
            print(show_mem_address(start))
    elif command == "show" and len(parts) >= 2:
        if parts[1].lower() == "all":
            show_all()
        elif parts[1].lower() == "profiler":
            show_profiler()
        else:
            print("Unknown show command.")
    else:
        print("Invalid command. Please try again.")